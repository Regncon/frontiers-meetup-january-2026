package root

import (
	"encoding/json"
	"log"
	"net/http"
	"strconv"

	"github.com/Regncon/frontiers-meetup-january-2026/components"
	"github.com/Regncon/frontiers-meetup-january-2026/helpers"
	"github.com/go-chi/chi/v5"
	"github.com/gorilla/sessions"
	"github.com/nats-io/nats.go/jetstream"
	datastar "github.com/starfederation/datastar-go/datastar"
)

var counter int

func RootLayoutRoute(router chi.Router, store sessions.Store, kv jetstream.KeyValue) {
	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		components.BaseLayout(
			"Frontiers Meetup",
			rootPageFirstLoad(),
		).Render(ctx, w)
	})

	router.Route("/root", func(rootRouter chi.Router) {
		rootRouter.Route("/api", func(rootApiRouter chi.Router) {
			rootApiRouter.Get("/", func(w http.ResponseWriter, r *http.Request) {
				log.Println("Root API SSE connected")
				ctx := r.Context()
				sse := datastar.NewSSE(w, r)

				sessionID, pageState, err := helpers.LoadOrCreateState(w, r, kv, store)
				if err != nil {
					log.Println("Error loading or creating state:", err)
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				if err := sse.PatchElementTempl(rootPage()); err != nil {
					_ = sse.ConsoleError(err)
					log.Println("Error patching element template:", err)
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				watcher, err := kv.Watch(ctx, sessionID)
				if err != nil {
					log.Println("Error setting up KV watcher:", err)
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}
				defer watcher.Stop()
				log.Println("Root API SSE watching for updates")

				for {
					select {
					case <-ctx.Done():
						return

					case entry := <-watcher.Updates():
						if entry == nil {
							continue
						}

						if err := json.Unmarshal(entry.Value(), pageState); err != nil {
							http.Error(w, err.Error(), http.StatusInternalServerError)
							return
						}

						if err := sse.PatchElementTempl(rootPage()); err != nil {
							_ = sse.ConsoleError(err)
							return
						}
					}
				}
			})
			rootApiRouter.Post("/counter/increment", func(w http.ResponseWriter, r *http.Request) {

				counter++

				if err := helpers.BroadcastUpdate(kv, r); err != nil {
					log.Println("Error broadcasting update:", err)
					http.Error(w, "unable to broadcast update", http.StatusInternalServerError)
					return
				}
				// No content; the update will arrive via SSE
				w.WriteHeader(http.StatusNoContent)
			})
		})
	})

}

templ rootPageFirstLoad() {
	<div id="root-page-wrapper" data-on-load={ datastar.GetSSE("/root/api") }>
		<h1>First load</h1>
		@rootPageContent()
	</div>
}

templ rootPage() {
	<div id="root-page-wrapper">
		<h1>Second load</h1>
		@rootPageContent()
	</div>
}

templ rootPageContent() {
	<div>
		<h1>Welcome to the Frontiers Meetup</h1>
		<p>This is our first Templ-generated page.</p>
		<p>
			<strong>Counter:</strong>
			{ strconv.Itoa(counter) }
		</p>
		<button
			data-on-click={ templ.URL("@post('/root/api/counter/increment')") }
		>
			Increment counter
		</button>
	</div>
}
