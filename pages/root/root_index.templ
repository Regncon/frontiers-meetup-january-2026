package root

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"

	"github.com/Regncon/frontiers-meetup-january-2026/components"
	"github.com/Regncon/frontiers-meetup-january-2026/helpers"
	"github.com/go-chi/chi/v5"
	"github.com/gorilla/sessions"
	"github.com/nats-io/nats.go/jetstream"
	datastar "github.com/starfederation/datastar-go/datastar"
)

const presenterSessionName = "presenter-auth"

func RootLayoutRoute(router chi.Router, db *sql.DB, store sessions.Store, kv jetstream.KeyValue, logger *slog.Logger) {
	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		inviteKey := chi.URLParam(r, "inviteKey")

		sseURL := fmt.Sprintf("/%s/root/api", inviteKey)
		if r.URL.RawQuery != "" {
			sseURL = sseURL + "?" + r.URL.RawQuery
		}
		dataInit := fmt.Sprintf("@get('%s',{requestCancellation: 'disabled'})", sseURL)

		isPresenter := isPresenterFromSession(r, store)

		components.BaseLayout(
			"Frontiers Meetup",
			rootPageFirstLoad(db, inviteKey, dataInit, isPresenter),
		).Render(ctx, w)
	})

	router.Route("/root", func(rootRouter chi.Router) {
		rootRouter.Route("/api", func(rootApiRouter chi.Router) {
			rootApiRouter.Get("/", func(w http.ResponseWriter, r *http.Request) {
				logger.Info("Root API SSE connected")

				ctx := r.Context()
				sse := datastar.NewSSE(w, r)

				sessionID, pageState, err := helpers.LoadOrCreateState(w, r, kv, store)
				if err != nil {
					logger.Error("Error loading or creating state:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				inviteKey := chi.URLParam(r, "inviteKey")
				isPresenter := isPresenterFromSession(r, store)

				if err := sse.PatchElementTempl(rootPage(db, inviteKey, isPresenter)); err != nil {
					_ = sse.ConsoleError(err)
					logger.Error("Error sending initial page patch:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				watcher, err := kv.Watch(ctx, sessionID)
				if err != nil {
					logger.Error("Error setting up KV watcher:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}
				defer watcher.Stop()

				logger.Info("Root API SSE watcher started", slog.String("sessionID", sessionID))

				for {
					select {
					case <-ctx.Done():
						return

					case entry := <-watcher.Updates():
						if entry == nil {
							continue
						}

						if err := json.Unmarshal(entry.Value(), pageState); err != nil {
							http.Error(w, err.Error(), http.StatusInternalServerError)
							return
						}

						if err := sse.PatchElementTempl(rootPage(db, inviteKey, isPresenter)); err != nil {
							_ = sse.ConsoleError(err)
							return
						}
					}
				}
			})

			IncrementEmojiRoute(db, rootApiRouter, kv)
			TopNavigationRoutes(db, rootApiRouter, kv)
		})
	})
}

func isPresenterFromSession(r *http.Request, store sessions.Store) bool {
	sess, err := store.Get(r, presenterSessionName)
	if err != nil {
		return false
	}

	v, ok := sess.Values["presenter"].(bool)
	return ok && v
}

templ rootPageFirstLoad(db *sql.DB, inviteKey string, dataInit string, isPresenter bool) {
	<div id="root-page-wrapper" data-init={ dataInit }>
		@rootPageContent(db, inviteKey, isPresenter)
	</div>
}

templ rootPage(db *sql.DB, inviteKey string, isPresenter bool) {
	<div id="root-page-wrapper">
		@rootPageContent(db, inviteKey, isPresenter)
	</div>
}

templ rootPageContent(db *sql.DB, inviteKey string, isPresenter bool) {
	<div class="root-page">
		<main class="root-main">
			if isPresenter {
				@TopNavigation(db, inviteKey)
			}
			@ActiveSlide(db)
		</main>
		<footer class="emoji-bar" aria-label="Reactions">
			@EmojiCounter(db, inviteKey, "üëç")
			@EmojiCounter(db, inviteKey, "üéâ")
			@EmojiCounter(db, inviteKey, "üòÇ")
			@EmojiCounter(db, inviteKey, "üî•")
			@EmojiCounter(db, inviteKey, "‚ù§Ô∏è")
		</footer>
	</div>
}
