package root

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"

	"github.com/Regncon/frontiers-meetup-january-2026/components"
	"github.com/Regncon/frontiers-meetup-january-2026/helpers"
	"github.com/go-chi/chi/v5"
	"github.com/gorilla/sessions"
	"github.com/nats-io/nats.go/jetstream"
	datastar "github.com/starfederation/datastar-go/datastar"
	"github.com/delaneyj/toolbelt/embeddednats"
	"github.com/Regncon/frontiers-meetup-january-2026/services"
)

const presenterSessionName = "presenter-auth"

func RootLayoutRoute(
	router chi.Router,
	db *sql.DB,
	store sessions.Store,
	kv jetstream.KeyValue,
	logger *slog.Logger,
	localKey string,
	remoteKey string,
	ns *embeddednats.Server,
	ebs *services.EmojiBalloonService,
) {
	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		// Path A: ensure we have a session ID on the *initial* HTML render.
		sessionID, _, err := helpers.LoadOrCreateState(w, r, kv, store)
		if err != nil {
			logger.Error("Error loading or creating state:", slog.String("error", err.Error()))
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		inviteKey := chi.URLParam(r, "inviteKey")

		sseURL := fmt.Sprintf("/%s/root/api", inviteKey)
		if r.URL.RawQuery != "" {
			sseURL = sseURL + "?" + r.URL.RawQuery
		}
		dataInit := fmt.Sprintf("@get('%s',{requestCancellation: 'disabled'})", sseURL)

		isPresenter := isPresenterFromSession(r, store)

		components.BaseLayout(
			"Frontiers Meetup",
			rootPageFirstLoad(db, inviteKey, dataInit, isPresenter, sessionID, localKey, remoteKey),
		).Render(ctx, w)
	})

	router.Route("/root", func(rootRouter chi.Router) {
		rootRouter.Route("/api", func(rootApiRouter chi.Router) {
			rootApiRouter.Get("/", func(w http.ResponseWriter, r *http.Request) {
				logger.Info("Root API SSE connected")

				ctx := r.Context()
				sse := datastar.NewSSE(w, r)

				sessionID, pageState, err := helpers.LoadOrCreateState(w, r, kv, store)
				if err != nil {
					logger.Error("Error loading or creating state:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				inviteKey := chi.URLParam(r, "inviteKey")
				isPresenter := isPresenterFromSession(r, store)

				if err := sse.PatchElementTempl(rootPage(db, inviteKey, isPresenter, sessionID, localKey, remoteKey)); err != nil {
					_ = sse.ConsoleError(err)
					logger.Error("Error sending initial page patch:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}

				watcher, err := kv.Watch(ctx, sessionID)
				if err != nil {
					logger.Error("Error setting up KV watcher:", slog.String("error", err.Error()))
					http.Error(w, err.Error(), http.StatusInternalServerError)
					return
				}
				defer watcher.Stop()

				logger.Info("Root API SSE watcher started", slog.String("sessionID", sessionID))

				for {
					select {
					case <-ctx.Done():
						return

					case entry := <-watcher.Updates():
						if entry == nil {
							continue
						}

						if err := json.Unmarshal(entry.Value(), pageState); err != nil {
							http.Error(w, err.Error(), http.StatusInternalServerError)
							return
						}

						if err := sse.PatchElementTempl(rootPage(db, inviteKey, isPresenter, sessionID, localKey, remoteKey)); err != nil {
							_ = sse.ConsoleError(err)
							return
						}
					}
				}
			})

			IncrementEmojiRoute(rootApiRouter, ebs)
			TopNavigationRoutes(db, rootApiRouter, kv)

			// Poll feature routes (vote writes DB + broadcast update).
			PollVoteRoutes(db, rootApiRouter, kv, store)
		})
	})
}

func isPresenterFromSession(r *http.Request, store sessions.Store) bool {
	sess, err := store.Get(r, presenterSessionName)
	if err != nil {
		return false
	}

	v, ok := sess.Values["presenter"].(bool)
	return ok && v
}

templ rootPageFirstLoad(
	db *sql.DB,
	inviteKey string,
	dataInit string,
	isPresenter bool,
	sessionID string,
	localKey string,
	remoteKey string,
) {
	<div id="root-page-wrapper" data-init={ dataInit }>
		@rootPageContent(db, inviteKey, isPresenter, sessionID, localKey, remoteKey)
	</div>
}

templ rootPage(
	db *sql.DB,
	inviteKey string,
	isPresenter bool,
	sessionID string,
	localKey string,
	remoteKey string,
) {
	<div id="root-page-wrapper">
		@rootPageContent(db, inviteKey, isPresenter, sessionID, localKey, remoteKey)
	</div>
}

templ rootPageContent(
	db *sql.DB,
	inviteKey string,
	isPresenter bool,
	sessionID string,
	localKey string,
	remoteKey string,
) {
	<div class="app">
		if isPresenter {
			<div class="presenter-layout">
				<aside class="presenter-sidebar" aria-label="Slide list">
					@PresenterSlideList(db, inviteKey, sessionID, localKey, remoteKey)
				</aside>
				<div class="presenter-main">
					<header class="presenter-bar" aria-label="Presenter controls">
						@TopNavigation(db, inviteKey, sessionID, localKey, remoteKey)
					</header>
					<main class="stage" aria-label="Presentation">
						@ActiveSlide(db, inviteKey, sessionID, isPresenter, localKey, remoteKey)
					</main>
					<footer class="reactions" aria-label="Reactions">
						@EmojiVoteWidget(inviteKey)
					</footer>
				</div>
			</div>
		} else {
			<main class="stage" aria-label="Presentation">
				@ActiveSlide(db, inviteKey, sessionID, isPresenter, localKey, remoteKey)
			</main>
			<footer class="reactions" aria-label="Reactions">
				@EmojiVoteWidget(inviteKey)
			</footer>
		}
	</div>
}
