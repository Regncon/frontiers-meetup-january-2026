package root

import (
	"database/sql"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"github.com/Regncon/frontiers-meetup-january-2026/helpers"
	"github.com/go-chi/chi/v5"
	"github.com/gorilla/sessions"
	"github.com/nats-io/nats.go/jetstream"
)

/*
SQL (run once):

CREATE TABLE IF NOT EXISTS poll_votes (
  invite_key     TEXT NOT NULL,
  poll_key       TEXT NOT NULL,
  session_id     TEXT NOT NULL,
  option_key     TEXT NOT NULL,
  voted_at_unix  INTEGER NOT NULL,
  PRIMARY KEY (invite_key, poll_key, session_id)
);

CREATE INDEX IF NOT EXISTS idx_poll_votes_poll_invite
  ON poll_votes (poll_key, invite_key);

CREATE INDEX IF NOT EXISTS idx_poll_votes_poll_option_invite
  ON poll_votes (poll_key, option_key, invite_key);
*/

type PollOption struct {
	Key      string
	Text     string
	ImageURL string
}

type PollDefinition struct {
	Key              string
	QuestionText     string
	QuestionImageURL string
	Options          []PollOption
}

var pollDefinitions = map[string]PollDefinition{
	"dom-checkbox-limit": {
		Key:          "dom-checkbox-limit",
		QuestionText: "How many checkboxes can a simple Datastar + Go + SQLite app handle on a cheap VPS?",
		Options: []PollOption{
			{Key: "two", Text: "2 (DOM is slow)",
				ImageURL: "/static/slow.webp",
			},
			{Key: "tenk", Text: "About ~10,000 before the dom struggles)"},
			{Key: "fourfifty", Text: "The dom has gotten fast. About ~452,600 on my laptop)"},
			{
				Key:      "oneb",
				Text:     "One billion",
				ImageURL: "/static/one_billion.webp",
			},
		},
	},
}

func MustPoll(key string) PollDefinition {
	p, ok := pollDefinitions[key]
	if !ok {
		panic("unknown poll key: " + key)
	}
	return p
}

func pollHasOption(poll PollDefinition, optionKey string) bool {
	for _, opt := range poll.Options {
		if opt.Key == optionKey {
			return true
		}
	}
	return false
}

func getMyPollVote(db *sql.DB, inviteKey, pollKey, sessionID string) (string, error) {
	var optionKey string
	err := db.QueryRow(
		`SELECT option_key FROM poll_votes WHERE invite_key = ? AND poll_key = ? AND session_id = ?`,
		inviteKey, pollKey, sessionID,
	).Scan(&optionKey)

	if err == sql.ErrNoRows {
		return "", nil
	}
	if err != nil {
		return "", err
	}

	return optionKey, nil
}

func upsertPollVote(db *sql.DB, inviteKey, pollKey, sessionID, optionKey string) error {
	nowUnix := time.Now().Unix()
	_, err := db.Exec(`
		INSERT INTO poll_votes (invite_key, poll_key, session_id, option_key, voted_at_unix)
		VALUES (?, ?, ?, ?, ?)
		ON CONFLICT(invite_key, poll_key, session_id)
		DO UPDATE SET option_key = excluded.option_key, voted_at_unix = excluded.voted_at_unix
	`, inviteKey, pollKey, sessionID, optionKey, nowUnix)
	return err
}

func PollVoteRoutes(db *sql.DB, router chi.Router, kv jetstream.KeyValue, store sessions.Store) {
	router.Post("/poll/vote", func(w http.ResponseWriter, r *http.Request) {
		inviteKey := chi.URLParam(r, "inviteKey")
		pollKey := r.URL.Query().Get("poll")
		optionKey := r.URL.Query().Get("option")

		if inviteKey == "" {
			http.Error(w, "missing inviteKey", http.StatusBadRequest)
			return
		}
		if pollKey == "" {
			http.Error(w, "missing poll", http.StatusBadRequest)
			return
		}
		if optionKey == "" {
			http.Error(w, "missing option", http.StatusBadRequest)
			return
		}

		poll, ok := pollDefinitions[pollKey]
		if !ok {
			http.Error(w, "unknown poll", http.StatusBadRequest)
			return
		}
		if !pollHasOption(poll, optionKey) {
			http.Error(w, "unknown option", http.StatusBadRequest)
			return
		}

		sessionID, _, err := helpers.LoadOrCreateState(w, r, kv, store)
		if err != nil {
			http.Error(w, "failed to load or create session: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := upsertPollVote(db, inviteKey, pollKey, sessionID, optionKey); err != nil {
			http.Error(w, "failed to save vote: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := helpers.BroadcastUpdate(kv, r); err != nil {
			http.Error(w, "unable to broadcast update", http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusNoContent)
	})
}

func pollVotePostURL(inviteKey, pollKey, optionKey string) string {
	escapedPoll := url.QueryEscape(pollKey)
	escapedOption := url.QueryEscape(optionKey)
	return fmt.Sprintf("@post('/%s/root/api/poll/vote?poll=%s&option=%s')", inviteKey, escapedPoll, escapedOption)
}

func kahootThemeForIndex(index int) (bg string, badge string) {
	// Kahoot-ish: red, blue, yellow, green
	switch index % 4 {
	case 0:
		return "#e21b3c", "▲"
	case 1:
		return "#1368ce", "◆"
	case 2:
		return "#d89e00", "●"
	default:
		return "#26890c", "■"
	}
}

templ PollSlide(db *sql.DB, inviteKey string, sessionID string, poll PollDefinition) {
	{{ selectedOptionKey, _ := getMyPollVote(db, inviteKey, poll.Key, sessionID) }}
	<div class="slide" style="display:flex; flex-direction:column; gap:1.5rem; width:100%; height:100%;">
		<div style="display:flex; flex-direction:column; gap:0.75rem;">
			if poll.QuestionText != "" {
				<h1 style="margin:0;">{ poll.QuestionText }</h1>
			}
			if poll.QuestionImageURL != "" {
				<img src={ poll.QuestionImageURL } alt="Poll question image" style="max-width:100%; max-height:40vh; border-radius:16px; object-fit:contain;"/>
			}
			<p style="margin:0; opacity:0.85;">
				Pick one. You can change your vote anytime.
			</p>
		</div>
		<div style="display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:1rem; flex:1;">
			for i, opt := range poll.Options {
				{{ bg, badge := kahootThemeForIndex(i) }}
				{{ isSelected := (opt.Key == selectedOptionKey) }}
				<button
					type="button"
					data-on:click={ templ.URL(pollVotePostURL(inviteKey, poll.Key, opt.Key)) }
					aria-pressed={ fmt.Sprintf("%t", isSelected) }
					style={ fmt.Sprintf(
						`display:flex; align-items:stretch; justify-content:stretch; gap:0.75rem; padding:1rem; border-radius:18px; border:%s; background:%s; color:white; cursor:pointer; text-align:left; width:100%%; min-height:6.5rem; box-shadow:%s;`,
						func() string {
							if isSelected {
								return "4px solid rgba(255,255,255,0.95)"
							}
							return "2px solid rgba(255,255,255,0.25)"
						}(),
						bg,
						func() string {
							if isSelected {
								return "0 0 0 6px rgba(255,255,255,0.18)"
							}
							return "0 0 0 0 rgba(0,0,0,0)"
						}(),
					) }
				>
					<div style="display:flex; align-items:center; justify-content:center; width:3rem; min-width:3rem; font-size:1.75rem; font-weight:900; background:rgba(0,0,0,0.18); border-radius:14px;">
						{ badge }
					</div>
					<div style="display:flex; flex-direction:column; gap:0.5rem; flex:1; min-width:0;">
						if opt.ImageURL != "" {
							<img src={ opt.ImageURL } alt="" style="max-width:100%; max-height:14vh; border-radius:14px; object-fit:cover; background:rgba(255,255,255,0.08);"/>
						}
						if opt.Text != "" {
							<div style="font-size:1.25rem; font-weight:800; line-height:1.15; word-break:break-word;">
								{ opt.Text }
							</div>
						}
						if isSelected {
							<div style="font-size:0.95rem; font-weight:700; opacity:0.95;">
								Selected
							</div>
						}
					</div>
				</button>
			}
		</div>
	</div>
}
