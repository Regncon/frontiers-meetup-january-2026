package root

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"

	"github.com/Regncon/frontiers-meetup-january-2026/services"
	"github.com/starfederation/datastar-go/datastar"
	"encoding/json"
)

func IncrementEmojiRoute(router chi.Router, ebs *services.EmojiBalloonService) {
	
	router.Get("/emoji/sse", func(w http.ResponseWriter, r *http.Request) {

		sse := datastar.NewSSE(w, r)
		ctx := r.Context()

		watcher, err := ebs.WatchUpdates(ctx)
		if err != nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}

		fmt.Println(ebs.Counter)
		thumbs_up := ebs.Counter.ThumbsUpEmojiCount
		confetti := ebs.Counter.ConfettiEmojiCount
		cry_laugh := ebs.Counter.CryLaughEmojiCount
		fire := ebs.Counter.FireEmojiCount
		heart := ebs.Counter.HeartEmojiCount

		for {
			select {
			case <- ctx.Done():
				return
			case <-watcher.Updates():
				fmt.Println("emoji_counter.templ")
				b, err := json.Marshal(ebs.Counter)

				if err != nil {
					http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
				}

				err = sse.PatchSignals(b)

				if err != nil {
					http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
				}

				emoji := ""

				if thumbs_up != ebs.Counter.ThumbsUpEmojiCount { 
					thumbs_up = ebs.Counter.ThumbsUpEmojiCount
					emoji = "üëç"
				}
				if confetti != ebs.Counter.ConfettiEmojiCount { 
					confetti = ebs.Counter.ConfettiEmojiCount
					emoji = "üéâ"
				}
				if cry_laugh != ebs.Counter.CryLaughEmojiCount { 
					cry_laugh = ebs.Counter.CryLaughEmojiCount
					emoji = "üòÇ"
				}
				if fire != ebs.Counter.FireEmojiCount { 
					fire = ebs.Counter.FireEmojiCount
					emoji = "üî•"
				}
				if heart != ebs.Counter.HeartEmojiCount { 
					heart = ebs.Counter.HeartEmojiCount
					emoji = "‚ù§Ô∏è"
				}

				err = sse.PatchElements(fmt.Sprintf(`<emoji-balloon emoji="%s"></emoji-balloon>`, emoji), datastar.WithSelector("body"), datastar.WithModeAppend())
				if err != nil {
					http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
				}
			}
		}
	})

	router.Post("/emoji/increment", func(w http.ResponseWriter, r *http.Request) {
		type Signals struct {
			Emoji string
		}
		var signals Signals
		err := datastar.ReadSignals(r, &signals)
		if err != nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}

		err = ebs.AddBalloon(r.Context(), signals.Emoji)
		if err != nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}
	})
}

func emojiIncrementPostURL(inviteKey string) string {
	return fmt.Sprintf("@post('/%s/root/api/emoji/increment')", inviteKey)
}

func emojiVoteSSEGetURL(inviteKey string) string {
	return fmt.Sprintf("@get('/%s/root/api/emoji/sse',{requestCancellation: 'disabled'})", inviteKey)
}

templ EmojiVoteWidget(inviteKey string) {
	<div style="display: flex; justify-content: center; flex: 1; gap: 12px; padding: 4px;" class="bottom-0 left-0 w-full flex justify-center flex flex-1 items-center"
		data-init={ emojiVoteSSEGetURL(inviteKey) }
		data-on:click__stop={ emojiIncrementPostURL(inviteKey)}
	>
		<button class="emoji-balloon-button" data-on:click="$emoji='üëç';">
			<span data-text="$ThumbsUpEmojiCount"></span>
			üëç
		</button>
		<button class="emoji-balloon-button" data-on:click="$emoji='üéâ';">
			<span data-text="$ConfettiEmojiCount"></span>
			üéâ
		</button>
		<button class="emoji-balloon-button" data-on:click="$emoji='üòÇ';">
			<span data-text="$CryLaughEmojiCount"></span>
			üòÇ
		</button>
		<button class="emoji-balloon-button" data-on:click="$emoji='üî•';">
			<span data-text="$FireEmojiCount"></span>
			üî•
		</button>
		<button class="emoji-balloon-button" data-on:click="$emoji='‚ù§Ô∏è';">
			<span data-text="$HeartEmojiCount"></span>
			‚ù§Ô∏è
		</button>
	</div>	
}
