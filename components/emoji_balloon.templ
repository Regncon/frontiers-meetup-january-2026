package components

import ()

func emojiBalloonScript() string {
	// Keep it as a plain string so itâ€™s easy to edit and stays self-contained.
	return `
<script type="module">
  class EmojiBalloon extends HTMLElement {
    static get observedAttributes() { return ["data-emoji", "data-count"]; }

    constructor() {
      super();
      this._storageKey = null;
      this._initialised = false;
      this._cleanupTimer = null;
    }

    connectedCallback() {
      const emoji = this.getAttribute("data-emoji") || "";
      const countStr = this.getAttribute("data-count") || "0";
      const count = Number(countStr);

      this._storageKey = this._makeStorageKey(emoji);

      // No animation on first load: if we have no stored value, store and exit.
      const previous = this._readStoredCount();
      if (previous === null) {
        this._writeStoredCount(count);
        this._initialised = true;
        return;
      }

      // If element is inserted later (due to patch), treat it as initialised
      // and only animate on actual increase.
      if (count > previous) {
        this._animate();
      }

      this._writeStoredCount(count);
      this._initialised = true;
    }

    attributeChangedCallback(name, oldValue, newValue) {
      // Ignore parser-initial sets and no-op changes.
      if (!this.isConnected) return;
      if (oldValue === null) return;
      if (oldValue === newValue) return;

      // Wait until connectedCallback has run at least once.
      if (!this._initialised) return;

      // On any update, compare counts.
      const emoji = this.getAttribute("data-emoji") || "";
      const countStr = this.getAttribute("data-count") || "0";
      const count = Number(countStr);

      this._storageKey = this._makeStorageKey(emoji);

      const previous = this._readStoredCount();
      if (previous !== null && count > previous) {
        this._animate();
      }

      this._writeStoredCount(count);
    }

    _makeStorageKey(emoji) {
      // Key is per-tab (sessionStorage) and per-emoji.
      // If emoji is empty, we still get a stable key.
      return "fmj26:emojiCount:" + encodeURIComponent(emoji);
    }

    _readStoredCount() {
      if (!this._storageKey) return null;
      const raw = sessionStorage.getItem(this._storageKey);
      if (raw === null) return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    }

    _writeStoredCount(count) {
      if (!this._storageKey) return;
      if (!Number.isFinite(count)) return;
      sessionStorage.setItem(this._storageKey, String(count));
    }

    _animate() {
      const target = this.querySelector("[data-emoji-balloon-target]");
      if (!target) return;

      target.classList.remove("emoji-balloon-pop");
      // Force reflow so the animation reliably restarts.
      void target.offsetWidth;
      target.classList.add("emoji-balloon-pop");

      clearTimeout(this._cleanupTimer);
      this._cleanupTimer = setTimeout(() => {
        target.classList.remove("emoji-balloon-pop");
      }, 320);
    }
  }

  if (!customElements.get("emoji-balloon")) {
    customElements.define("emoji-balloon", EmojiBalloon);
  }
</script>

<style>
  @keyframes emojiBalloonPop {
    0%   { transform: translateY(0) scale(1);    }
    45%  { transform: translateY(-10px) scale(1.14); }
    100% { transform: translateY(-16px) scale(1.02); }
  }

  .emoji-balloon-pop {
    display: inline-block;
    animation: emojiBalloonPop 320ms cubic-bezier(0.2, 0.9, 0.2, 1);
    will-change: transform;
  }
</style>
`
}

templ EmojiBalloonAssets() {
	@templ.Raw(emojiBalloonScript())
}
