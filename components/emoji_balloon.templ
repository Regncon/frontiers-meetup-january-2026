package components

import ()

func emojiBalloonScript() string {
	return `
<script type="module">
  class EmojiBalloon extends HTMLElement {
    constructor() {
      super();
      this._storageKey = null;
      this._cleanupTimer = null;
      this._hasConnected = false;
      this._activeAnimation = null;
    }

    connectedCallback() {
      this._hasConnected = true;
      this._runCheck("connectedCallback");
    }

    static get observedAttributes() {
      return ["data-emoji", "data-count"];
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (!this.isConnected) return;
      if (!this._hasConnected) return;

      // Datastar patches can update attributes; re-check on changes.
      if (oldValue === newValue) return;
      this._runCheck("attributeChangedCallback: " + name);
    }

    _runCheck(source) {
      const emoji = (this.getAttribute("data-emoji") || "").trim();
      const countStrRaw = this.getAttribute("data-count") || "0";
      const countStr = countStrRaw.trim();
      const count = Number(countStr);

      this._storageKey = "fmj26:emojiCount:" + encodeURIComponent(emoji);

      const storedRaw = sessionStorage.getItem(this._storageKey);
      const stored = storedRaw === null ? null : Number(storedRaw);

      // Debug: comment out these logs once it works.
      console.log("[emoji-balloon]", source, {
        emoji,
        countStrRaw,
        count,
        storedRaw,
        stored,
        storageKey: this._storageKey
      });

      if (!Number.isFinite(count)) {
        console.warn("[emoji-balloon] count is not a number:", countStrRaw);
        return;
      }

      // First time for this emoji in this tab: store and do not animate.
      if (storedRaw === null) {
        sessionStorage.setItem(this._storageKey, String(count));
        return;
      }

      if (Number.isFinite(stored) && count > stored) {
        this._animate();
      }

      sessionStorage.setItem(this._storageKey, String(count));
    }

    _animate() {
      const target = this.querySelector("[data-emoji-balloon-target]");
      console.log("[emoji-balloon] animate target:", target);
      if (!target) return;

      // Cancel any in-flight animation so repeated clicks feel snappy.
      if (this._activeAnimation) {
        this._activeAnimation.cancel();
        this._activeAnimation = null;
      }

      // Cute balloon pop: up + slight overshoot.
      this._activeAnimation = target.animate(
        [
          { transform: "translateY(0px) scale(1)" },
          { transform: "translateY(-12px) scale(1.14)", offset: 0.45 },
          { transform: "translateY(-18px) scale(1.02)" },
        ],
        {
          duration: 320,
          easing: "cubic-bezier(0.2, 0.9, 0.2, 1)",
          fill: "none",
        }
      );
    }
  }

  if (!customElements.get("emoji-balloon")) {
    customElements.define("emoji-balloon", EmojiBalloon);
    console.log("[emoji-balloon] custom element defined");
  } else {
    console.log("[emoji-balloon] custom element already defined");
  }
</script>

<style>
  @keyframes emojiBalloonPop {
    0%   { transform: translateY(0) scale(1); }
    45%  { transform: translateY(-10px) scale(1.14); }
    100% { transform: translateY(-16px) scale(1.02); }
  }

  .emoji-balloon-pop {
    display: inline-block;
    animation: emojiBalloonPop 320ms cubic-bezier(0.2, 0.9, 0.2, 1);
    will-change: transform;
  }
</style>
`
}

templ EmojiBalloonAssets() {
	@templ.Raw(emojiBalloonScript())
}
