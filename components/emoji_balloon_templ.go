// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.960
package components

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import ()

func emojiBalloonScript() string {
	// Keep it as a plain string so itâ€™s easy to edit and stays self-contained.
	return `
<script type="module">
  class EmojiBalloon extends HTMLElement {
    static get observedAttributes() { return ["data-emoji", "data-count"]; }

    constructor() {
      super();
      this._storageKey = null;
      this._initialised = false;
      this._cleanupTimer = null;
    }

    connectedCallback() {
      const emoji = this.getAttribute("data-emoji") || "";
      const countStr = this.getAttribute("data-count") || "0";
      const count = Number(countStr);

      this._storageKey = this._makeStorageKey(emoji);

      // No animation on first load: if we have no stored value, store and exit.
      const previous = this._readStoredCount();
      if (previous === null) {
        this._writeStoredCount(count);
        this._initialised = true;
        return;
      }

      // If element is inserted later (due to patch), treat it as initialised
      // and only animate on actual increase.
      if (count > previous) {
        this._animate();
      }

      this._writeStoredCount(count);
      this._initialised = true;
    }

    attributeChangedCallback(name, oldValue, newValue) {
      // Ignore parser-initial sets and no-op changes.
      if (!this.isConnected) return;
      if (oldValue === null) return;
      if (oldValue === newValue) return;

      // Wait until connectedCallback has run at least once.
      if (!this._initialised) return;

      // On any update, compare counts.
      const emoji = this.getAttribute("data-emoji") || "";
      const countStr = this.getAttribute("data-count") || "0";
      const count = Number(countStr);

      this._storageKey = this._makeStorageKey(emoji);

      const previous = this._readStoredCount();
      if (previous !== null && count > previous) {
        this._animate();
      }

      this._writeStoredCount(count);
    }

    _makeStorageKey(emoji) {
      // Key is per-tab (sessionStorage) and per-emoji.
      // If emoji is empty, we still get a stable key.
      return "fmj26:emojiCount:" + encodeURIComponent(emoji);
    }

    _readStoredCount() {
      if (!this._storageKey) return null;
      const raw = sessionStorage.getItem(this._storageKey);
      if (raw === null) return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    }

    _writeStoredCount(count) {
      if (!this._storageKey) return;
      if (!Number.isFinite(count)) return;
      sessionStorage.setItem(this._storageKey, String(count));
    }

    _animate() {
      const target = this.querySelector("[data-emoji-balloon-target]");
      if (!target) return;

      target.classList.remove("emoji-balloon-pop");
      // Force reflow so the animation reliably restarts.
      void target.offsetWidth;
      target.classList.add("emoji-balloon-pop");

      clearTimeout(this._cleanupTimer);
      this._cleanupTimer = setTimeout(() => {
        target.classList.remove("emoji-balloon-pop");
      }, 320);
    }
  }

  if (!customElements.get("emoji-balloon")) {
    customElements.define("emoji-balloon", EmojiBalloon);
  }
</script>

<style>
  @keyframes emojiBalloonPop {
    0%   { transform: translateY(0) scale(1);    }
    45%  { transform: translateY(-10px) scale(1.14); }
    100% { transform: translateY(-16px) scale(1.02); }
  }

  .emoji-balloon-pop {
    display: inline-block;
    animation: emojiBalloonPop 320ms cubic-bezier(0.2, 0.9, 0.2, 1);
    will-change: transform;
  }
</style>
`
}

func EmojiBalloonAssets() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templ.Raw(emojiBalloonScript()).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
